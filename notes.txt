16. Async

// MODERN WAY OF AJAX CALLING(fetch API) IMP

// returns a "Promise" IMP
// object used as a placeholder for the future result of an asynchronous operation
// OR a container for a future value

// used to 'chain promises' ==> escaping callback hell IMP
// const request = fetch(
//   'https://countries-api-836d.onrender.com/countries/name/portugal'
// );

// to consume fulfilled promise ==> .then() IMP
// to read data from response ==> .json() ==> returns a NEW PROMISE IMP ==> call another .then()

// we get a 'response' ==> turn it into 'json' ==> take the 'data' and render it into DOM

// Handling rejected promises IMP (fetch only rejects when there is no internet connection)
// second argument of .then()
// BETTER WAY:
// .catch() at the end of the chain (returns a promise)

// finally: always works regardless of promise result

// when 404 happens, fetch promise still gets fulfilled ==> we get normal error msg IMP
// getCountryDataAndNeighbour('sssdsdsdsds');
// custom msg:
/*
      if (!response.ok)
          // if it's false,
          throw new Error(`Country not found. ${response.status}`);
*/

// ALWAYS use catch (and finally when necessary) to handle promises (and errors) IMP

// instead of callback hell, we have a flat chain of promises IMP

// ALWAYS return a NESTED promise and handle it outside, don't do this: (it still works, but you just nest callbacks)
/*
fetch(`https://countries-api-836d.onrender.com/countries/alpha/${neighbour}`).then()
*/

 do this instead:
       return fetch(
         `https://countries-api-836d.onrender.com/countries/alpha/${neighbour}`
       );
     })
     .then()

// throwing an error inside a promise makes it rejected
      if (!neighbour) throw new Error('No neighbour found!');
.... .catch()

IMP
Async code works with the help of the callback queue, event loop and call stack. AND with an extra queue called the "MICROTASKS QUEUE" (filled with PROMISES .then(res => console.log(res)) ) that has priority over the normal callbacks from the callbacks queue. The event loop 'ticks', putting promises from the microtasks queue first, then callbacks from the callback queue into the call stack to be executed.

IMP
Async code in JS uses call stack + event loop + task queues. There are two queues:

Microtasks queue (Promises, queueMicrotask, MutationObserver) → runs first, drained completely.

Macro/callback queue (setTimeout, setInterval, I/O, DOM events) → runs only after microtasks are done.

The event loop continuously checks the call stack → if empty, it moves tasks from queues:

First drain all microtasks.

Then take one macro task.

Repeat.

// Most of the time we only consume promises (with .then)
// only build promises to wrap old callback based functions into promises (PROMISIFYING) IMP

// function that returns a promise (like .fetch())
// Promisifying setTimeout
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000); // we only want to make our code wait, no need for resolved values
  });
};

// add 'async' before 'function' ==> asynchronous (keeps running in the background while perf code inside of it, returns a promise automatically IMP)


// Using try/catch for error handling with async/await IMP
// ALWAYS USE TRY/CATCH WITH ASYNC IMP

// ASYNC CODE SHOULD ALWAYS HAVE ERROR HANDLNIG IMP IMP

// JS can't know what the return of the func is because it's still running, so it returns a promise (async)

console.log('1. Getting Location');
const city = whereAmI(); // executes last because async
console.log(city); // returns a promise (async always returns a promise)
console.log('3. Finished getting location.');

// IIFE (immediately invoked function expression)
(async function () {
  try {
    const city = await whereAmI();
    console.log(`2: ${city}`);
  } catch (err) {
    console.err(err);
  }
  console.log('3. Finished getting location.');
})();

// USEFUL IMP
// When you need multiple async operations that DON'T depend on eachother, ALWAYS use Promise.all() (combinator) IMP

const get3Countries = async function (c1, c2, c3) {
  try {
    // this works, but it runs in sequence (slower)
    // parallel would save loading time IMP
    // const [data1] = await getJSON(`https://restcountries.com/v3.1/name/${c1}`);
    // const [data2] = await getJSON(`https://restcountries.com/v3.1/name/${c2}`);
    // const [data3] = await getJSON(`https://restcountries.com/v3.1/name/${c3}`);
    // console.log([data1.capital, data2.capital, data3.capital]);

    // parallel:
    // returns a new promise that runs all promises at the same time
    // if one promise rejects ==> all reject (promise.all short circuits) IMP
    const data = await Promise.all(
      `https://restcountries.com/v3.1/name/${c1}`,
      `https://restcountries.com/v3.1/name/${c2}`,
      `https://restcountries.com/v3.1/name/${c3}`
    );

    console.log(data.map(d => d[0].capital));
  } catch (err) {
    console.log(err);
  }
};

// MOST IMPORTANT PROMISE COMBINATORS
// Promise.race()
// Promise.all()


// Promise.race (receives promises => returns ONE promise when one is settled (short circuits) (first settled promise wins the race IMP))
// if a fulfilled promise wins => it returns the fulfillment

(async function () {
  const res = await Promise.race([
    getJSON(`https://restcountries.com/v3.1/name/italy`),
    getJSON(`https://restcountries.com/v3.1/name/egypt`),
    getJSON(`https://restcountries.com/v3.1/name/mexico`),
  ]);
})();

// very useful to prevent never ending promises (or very long)

IMPORTANT:
template to use for basic ajax calls:

const showRecipe = async function () {
  try {
    const res = await fetch(
      'https://forkify-api.jonas.io/api/v2/recipes/5ed6604591c37cdc054bc886'
    );
    const data = await res.json();

    if (!res.ok) throw new Error(`${data.message} (${res.status})`);

    console.log(res, data);
  } catch (err) {
    alert(err);
  }
};



17. Modern JS 

// using a module bundler is very IMPortant

// modules get executed first (hoisted up)

// all top level variables are private to the module itself

export const addToCart = function (product, quantity) {
  cart.push(product, quantity);
  console.log(`${quantity} ${product} added to cart`);
};

// named imports: have to have same name, curly braces IMP
// import { addToCart, totalPrice as price, qt } from './shoppingCart';


// creating an object that contains every import IMP
// like exporting a public API as a class
// import * as ShoppingCart from './shoppingCart.js';
// ShoppingCart.addToCart('bread', 5);


// DEFAULT EXPORTS
// used when exporting only 1 thing per module

export default function (product, quantity) {
  cart.push(product, quantity);
  console.log(`${quantity} ${product} added to cart`);
}

// imports the DEFAULT EXPORT, no matter what it's called IMP
// we CAN mix both exports, but it's not advised IMP
// import add, { addToCart, totalPrice as price, qt } from './shoppingCart.js';

// // Top level await: can use await outside of async ONLY in modules IMP

// IMPorant console (cmd) commands:

cd..
cd + tab
dir 
mkdir TEST (make a folder)
copy nul index.html (make a file)
del TEST (removes files from test folder)
rmdir TEST (remove an EMPTY folder)

// IMPortant npm commands:

npm i 'package'
npm un 'package'
npm i (no package name => installs all package dependancies from package.json)

lodash/leaftet/other libraries are NORMAL dependancies

PARCEL/other bundlers/tools are devDependencies (not actually used in the code, but still necessary, just another CLI)

use parcel (installed locally): IMP (works with all commonjs modules)
1. npx (application built into npm)
npx parcel index.html (index is the 'entry point' ==> where we include script.js)
2. npm script
(in package.json:
  "scripts": {
    "start": "parcel index.html"
  },
)
then: npm run start

// goal of using parcel here: bundle three modules together (script, shoppingCart, clonedeep)
parcel creates a 'dist' (distribution) folder ==> send it for production (code in this folder is sent to final users, combines all modules into 1 script file IMP)

doesn't refresh the whole page when changing a module: IMP (saves logged in state, etc)
if (module.hot) {
  module.hot.accept();
}

// when we are done developing the project, we build the FINAL BUNDLE (compressed, deadcode elimination) IMP
(in package.json)
  "scripts": {
    "build": "parcel build index.html"
  },

// install globally: (doesn't need the intermediate step of an npm script)
// installing locally is recommended (to stay updated)
npm i parcel -g


IMP

// Babel can only convert/transpile ES6 Syntax (arrow functions, classes, const, spread operator), NOT things like promises, .find(), we need to POLYFILL those IMP

polyfill everything: import 'core-js/stable' (usually used, but higher bundle size)
polyfill promise specifically: import 'core-js/stable/promise'
polyfilling async functions: import 'regenerator-runtime/runtime';

always install renegerator-runtme
npm i regenerator-runtime

IMP
like following a recipe:

parcel = bundler (parcel automatically uses babel)
babel = transpiler (turns modern code back into es5)
polyfill with core-js/stable
async functions with regenerator-runtime/runtime

IMPERATIVE vs DECLARATIVE paradigms

IMPERATIVE:
- programmer explains HOW to do things (step-by-step recipe of a cake)

const arr = [2,4,6,8]
const doubled = []

for(let i =0; i < arr.length, i++)
doubled[i] = arr[i] * 2

DECLARATIVE:
- programmer tells WHAT to do (description of a cake)
- steps are abstracted away (more modern)

const arr = [2,4,6,8]
const doubled = arr.map(n => n * 2)

FUNCTIONAL PARADIGM (React is based on this) IMP
- Declarative programming paradigm
- idea of combining many pure functions, avoiding side effects and mutating data
- side effect: modification (mutation) of any data OUTSIDE of the function (mutating external variables, logging to console, writing to DOM, etc.)
- pure function: no side effects, doesn't depend on external variables (given the same inputs, always returns same outputs)
- immutability: state(data) is never modified, instead state is copied and the copy is mutated and returned

func progr techniques: IMP
- try to avoid data mutations
- use built-in methods that don't produce side effects
- .map(), .filter(), .reduce()
- try to avoid side effects in functions

Declarative Syntax:
- array and object destructuring
- use spread, ternary operator, template literals

We ALWAYS need some side effects (console.log, etc.), but push them to the end 

SASS (sassy css)
- better way of writing css for large apps
- browser doesn't understand it directly, so Parcel converts it

// MVC: IMP
We export stuff from the views and models so that the controllers can use them

timeout(10) ==> bad, 10 is a 'magic number' (not obvious at first glance)
 ==> timeout(TIMEOUT_SEC) (imported from config.js)

// converts 'string' HTML to an actual DOM node object
const newDOM = document.createRange().createContextualFragment(newMarkup);

// using 'isEqualNode' to compare elements from both DOMs
// if dom elem is different, change current element's content to the new one
// nodeValue only extracts the TEXT CONTENT of an element IMP
if (
!newEl.isEqualNode(curEl) &&
newEl.firstChild.nodeValue.trim() !== ''
) {
  curEl.textContent = newEl.textContent;
}


// When we add something, we need the entire data
export const addBookMark = function (recipe) 

// But when we delete something, we only need it's ID
export const addBookMark = function (id)

Object.entries() // converts to an array

const data = Object.fromEntries(dataArr); // converts an array of entries to an object

// startsWith IMP
const ingredients = Object.entries(newRecipe).filter(
  entry => entry[0].startsWith('ingredient') && entry[1] !== ''
);

IMP handy trick to conditionally render an attribute
...(recipe.key && { key: recipe.key }), // only adds the key attribute if there is a key