16. Async

// MODERN WAY OF AJAX CALLING(fetch API) IMP

// returns a "Promise" IMP
// object used as a placeholder for the future result of an asynchronous operation
// OR a container for a future value

// used to 'chain promises' ==> escaping callback hell IMP
// const request = fetch(
//   'https://countries-api-836d.onrender.com/countries/name/portugal'
// );

// to consume fulfilled promise ==> .then() IMP
// to read data from response ==> .json() ==> returns a NEW PROMISE IMP ==> call another .then()

// we get a 'response' ==> turn it into 'json' ==> take the 'data' and render it into DOM

// Handling rejected promises IMP (fetch only rejects when there is no internet connection)
// second argument of .then()
// BETTER WAY:
// .catch() at the end of the chain (returns a promise)

// finally: always works regardless of promise result

// when 404 happens, fetch promise still gets fulfilled ==> we get normal error msg IMP
// getCountryDataAndNeighbour('sssdsdsdsds');
// custom msg:
/*
      if (!response.ok)
          // if it's false,
          throw new Error(`Country not found. ${response.status}`);
*/

// ALWAYS use catch (and finally when necessary) to handle promises (and errors) IMP

// instead of callback hell, we have a flat chain of promises IMP

// ALWAYS return a NESTED promise and handle it outside, don't do this: (it still works, but you just nest callbacks)
/*
fetch(`https://countries-api-836d.onrender.com/countries/alpha/${neighbour}`).then()
*/

 do this instead:
       return fetch(
         `https://countries-api-836d.onrender.com/countries/alpha/${neighbour}`
       );
     })
     .then()

// throwing an error inside a promise makes it rejected
      if (!neighbour) throw new Error('No neighbour found!');
.... .catch()

IMP
Async code works with the help of the callback queue, event loop and call stack. AND with an extra queue called the "MICROTASKS QUEUE" (filled with PROMISES .then(res => console.log(res)) ) that has priority over the normal callbacks from the callbacks queue. The event loop 'ticks', putting promises from the microtasks queue first, then callbacks from the callback queue into the call stack to be executed.

IMP
Async code in JS uses call stack + event loop + task queues. There are two queues:

Microtasks queue (Promises, queueMicrotask, MutationObserver) → runs first, drained completely.

Macro/callback queue (setTimeout, setInterval, I/O, DOM events) → runs only after microtasks are done.

The event loop continuously checks the call stack → if empty, it moves tasks from queues:

First drain all microtasks.

Then take one macro task.

Repeat.

// Most of the time we only consume promises (with .then)
// only build promises to wrap old callback based functions into promises (PROMISIFYING) IMP

// function that returns a promise (like .fetch())
// Promisifying setTimeout
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000); // we only want to make our code wait, no need for resolved values
  });
};

// add 'async' before 'function' ==> asynchronous (keeps running in the background while perf code inside of it, returns a promise automatically IMP)


// Using try/catch for error handling with async/await IMP
// ALWAYS USE TRY/CATCH WITH ASYNC IMP

// ASYNC CODE SHOULD ALWAYS HAVE ERROR HANDLNIG IMP IMP

// JS can't know what the return of the func is because it's still running, so it returns a promise (async)

console.log('1. Getting Location');
const city = whereAmI(); // executes last because async
console.log(city); // returns a promise (async always returns a promise)
console.log('3. Finished getting location.');

// IIFE (immediately invoked function expression)
(async function () {
  try {
    const city = await whereAmI();
    console.log(`2: ${city}`);
  } catch (err) {
    console.err(err);
  }
  console.log('3. Finished getting location.');
})();

// USEFUL IMP
// When you need multiple async operations that DON'T depend on eachother, ALWAYS use Promise.all() (combinator) IMP

const get3Countries = async function (c1, c2, c3) {
  try {
    // this works, but it runs in sequence (slower)
    // parallel would save loading time IMP
    // const [data1] = await getJSON(`https://restcountries.com/v3.1/name/${c1}`);
    // const [data2] = await getJSON(`https://restcountries.com/v3.1/name/${c2}`);
    // const [data3] = await getJSON(`https://restcountries.com/v3.1/name/${c3}`);
    // console.log([data1.capital, data2.capital, data3.capital]);

    // parallel:
    // returns a new promise that runs all promises at the same time
    // if one promise rejects ==> all reject (promise.all short circuits) IMP
    const data = await Promise.all(
      `https://restcountries.com/v3.1/name/${c1}`,
      `https://restcountries.com/v3.1/name/${c2}`,
      `https://restcountries.com/v3.1/name/${c3}`
    );

    console.log(data.map(d => d[0].capital));
  } catch (err) {
    console.log(err);
  }
};